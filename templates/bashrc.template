# If not running interactively, don't do anything
case $- in *i*) ;; *) return ;; esac

# --- Locales & editor (coh√©rent sur serveurs)
export LANG="${LANG:-fr_FR.UTF-8}"
export LC_ALL="${LC_ALL:-fr_FR.UTF-8}"
export EDITOR="${EDITOR:-nano}"
export VISUAL="${VISUAL:-nano}"
export PAGER="${PAGER:-less}"
# Prompt lisible dans less (messages en anglais c√¥t√© "code")
export LESS='-R --mouse --ignore-case --LONG-PROMPT --prompt="Less ‚Üí %f  %lb/%L  (line %l)"'
# Par prudence, d√©sactive les fonctions risqu√©es de less (! et |).
export LESSSECURE=1

# --- Defaults s√©curit√© (interactif)
# Masque par d√©faut : fichiers non accessibles aux "others"
umask 027
# Emp√™che l'√©crasement involontaire avec '>' (utiliser '>|' pour forcer)
set -o noclobber

# --- Historique : volumineux, horodat√©, partag√© entre sessions sans flush complet
export HISTSIZE=50000
export HISTFILESIZE=100000
export HISTTIMEFORMAT='%F %T  '
export HISTCONTROL=ignoreboth:erasedups
# Ignore les commandes banales dans l'historique (ajoute/retire √† ton go√ªt)
export HISTIGNORE='ls:ll:la:cd:pwd:exit:clear'

# --- Bash options (qualit√© de vie)
shopt -s autocd              # 'cd' implicite
shopt -s cdspell dirspell    # tol√©rance fautes de frappe sur cd/dirs
shopt -s checkjobs           # avertit si jobs en arri√®re-plan √† la fermeture
shopt -s extglob globstar    # globbing avanc√© + ** r√©cursif
shopt -s histappend cmdhist  # concat√®ne l'historique + conserve commandes multilignes
shopt -s checkwinsize        # met √† jour LINES/COLUMNS
# Readline : compl√©tion sympa
bind 'set completion-ignore-case on'
bind 'set show-all-if-ambiguous on'
bind '"\e[Z": menu-complete-backward'

# --- PATH helpers (ajoute sans doublon)
path_prepend() { case ":$PATH:" in *":$1:"*) ;; *) PATH="$1:$PATH";; esac; }
path_append()  { case ":$PATH:" in *":$1:"*) ;; *) PATH="$PATH:$1";; esac; }

# --- PATH & outils (ajoute si pr√©sents)
[[ -d "$HOME/.local/bin" ]] && path_prepend "$HOME/.local/bin"
[[ -d "$HOME/bin"        ]] && path_prepend "$HOME/bin"
path_append "/usr/games"
path_append "/usr/local/games"
export PATH

# --- Couleurs LS_COLORS (sans r√©√©craser les alias ls)
if command -v dircolors >/dev/null 2>&1; then
  if [[ -r "$HOME/.dircolors" ]]; then
    eval "$(dircolors -b "$HOME/.dircolors")"
  else
    eval "$(dircolors -b)"
  fi
fi

# --- ls/grep am√©lior√©s (eza/lsd si dispo) ‚Äî d√©fini UNE SEULE FOIS
if command -v eza >/dev/null 2>&1; then
  alias ls='eza --group-directories-first --git --icons=auto'
  alias ll='eza -l --group-directories-first --git --icons=auto'
  alias la='eza -la --group-directories-first --git --icons=auto'
elif command -v lsd >/dev/null 2>&1; then
  alias ls='lsd --group-dirs=first'
  alias ll='lsd -l --group-dirs=first'
  alias la='lsd -la --group-dirs=first'
else
  alias ls='ls --color=auto --group-directories-first'
  alias ll='ls -alF --color=auto --group-directories-first'
  alias la='ls -A --color=auto --group-directories-first'
fi
alias grep='grep --color=auto'
alias fgrep='grep -F --color=auto'
alias egrep='grep -E --color=auto'
alias df='df -h'
alias free='free -h'
alias folder='du -h --max-depth=1 . | sort -hr'
# S√©curit√© douce (n'affecte pas les scripts)
alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# --- Sudo helpers
please() { eval sudo "$(fc -ln -1)"; }
# Espace final volontaire pour permettre l'expansion de l'alias suivant (ex: "pls ll")
alias pls='sudo '
alias sano='sudo -E nano'

# --- APT (Debian/Ubuntu) : raccourcis utiles, idempotents
alias au='sudo apt update'
alias aug='sudo apt update && sudo apt -y upgrade'
alias asr='apt search'
alias ain='sudo apt -y install'
alias arm='sudo apt -y remove'
alias apc='sudo apt -y autoremove && sudo apt -y autoclean'

# --- Git : logs lisibles & raccourcis
alias g='git'
alias ga='git add'
alias gb='git branch'
alias gco='git checkout'
alias gcob='git checkout -b'
alias gst='git status -sb'
alias gl='git log --oneline --decorate --graph --all'
alias gcm='git commit -m'
alias gca='git commit -a -m'
alias gpf='git push --force-with-lease'
alias gpo='git push origin HEAD'
alias grhh='git reset --hard HEAD'
alias gundo='git reset --soft HEAD~1'
alias gpr='git pull --rebase --autostash'

# Configure le pager Git une seule fois si rien n'est d√©j√† d√©fini
if command -v git >/dev/null 2>&1; then
  if command -v delta >/dev/null 2>&1; then
    git config --global --get core.pager >/dev/null 2>&1 || git config --global core.pager delta
  elif command -v diff-so-fancy >/dev/null 2>&1; then
    git config --global --get core.pager >/dev/null 2>&1 || git config --global core.pager "diff-so-fancy | less --tabs=4 -RFX"
  fi
fi

# --- R√©seaux / IP
alias myip='curl -s --max-time 2 https://ifconfig.me || dig +short myip.opendns.com @resolver1.opendns.com'
alias ports='ss -tulpn'

# --- Aliases divers (optionnels si grc/yt-dlp pr√©sents)
if command -v grc >/dev/null 2>&1; then
  alias tail='grc tail'
  alias ifconfig='grc ifconfig'
fi
if command -v yt-dlp >/dev/null 2>&1; then
  alias youtubedl="yt-dlp -f 'bestaudio' -o '%(artist)s - %(title)s.%(ext)s'"
elif command -v youtube-dl >/dev/null 2>&1; then
  alias youtubedl="youtube-dl -f 'bestaudio' -o '%(artist)s - %(title)s.%(ext)s'"
fi

# --- Symfony / PHP
alias s='symfony '
alias c='symfony console '
alias fix='vendor/bin/php-cs-fixer fix src/ && vendor/bin/phpstan'

# --- Python venv helpers (plus robuste qu'un chemin cod√© en dur)
mkvenv() {
  local target="${1:-.venv}"
  python3 -m venv "$target" && . "$target/bin/activate"
}
workon() {
  [[ -d ".venv" ]] && . ".venv/bin/activate" || echo "No .venv found in current directory."
}

# --- Chargement des alias utilisateur
[[ -f "$HOME/.bash_aliases" ]] && . "$HOME/.bash_aliases"

# --- Fonctions utilitaires

# man pages coloris√©es
man() {
  env \
  LESS_TERMCAP_mb=$'\E[01;31m' \
  LESS_TERMCAP_md=$'\E[01;31m' \
  LESS_TERMCAP_me=$'\E[0m' \
  LESS_TERMCAP_se=$'\E[0m' \
  LESS_TERMCAP_so=$'\E[01;31m' \
  LESS_TERMCAP_ue=$'\E[0m' \
  LESS_TERMCAP_us=$'\E[01;32m' \
  man "$@"
}

log()   { printf "\e[32m%s\e[0m\n" "$1"; }
error() { printf "\e[31m%s\e[0m\n" "$1" >&2; }

mkcd () { mkdir -p -- "$1" && cd -- "$1"; }

extract () { # D√©compresse selon l'extension
  local f="$1"
  [[ -f "$f" ]] || { echo "File not found: $f"; return 1; }
  case "$f" in
    *.tar.bz2)   tar xjf "$f"   ;;
    *.tar.gz)    tar xzf "$f"   ;;
    *.tar.xz)    tar xJf "$f"   ;;
    *.tar.zst)   tar --zstd -xvf "$f" ;;
    *.tar)       tar xf "$f"    ;;
    *.tbz2)      tar xjf "$f"   ;;
    *.tgz)       tar xzf "$f"   ;;
    *.zip)       unzip "$f"     ;;
    *.rar)       unrar x "$f"   ;;
    *.7z)        7z x "$f"      ;;
    *.gz)        gunzip "$f"    ;;
    *.bz2)       bunzip2 "$f"   ;;
    *.xz)        unxz "$f"      ;;
    *)           echo "Unsupported archive format: $f" ; return 2 ;;
  esac
}

up () { # Remonte de N r√©pertoires (1 par d√©faut)
  local d="" limit="${1:-1}"
  for ((i=1; i<=limit; i++)); do d+="../"; done
  cd "$d" || return
}

timer () { # Chronom√®tre une commande
  local start end
  start=$(date +%s)
  "$@"
  end=$(date +%s)
  echo "‚è±  $(( end - start ))s"
}

# --- Prompt : couleurs + infos utiles, sans casser l'historique

# Helpers couleurs (g√®rent le comptage de longueur gr√¢ce √† \[ \])
rgb()   { printf "\e[38;2;%s;%s;%sm" "$1" "$2" "$3"; }
bgrgb() { printf "\e[48;2;%s;%s;%sm" "$1" "$2" "$3"; }
reset="\[\e[0m\]"
dim="\[\e[2m\]"
bold="\[\e[1m\]"
ul="\[\e[4m\]"
blue="\[\e[1;34m\]"
yellow="\[\e[1;33m\]"
green="\[\e[0;32m\]"
cyan="\[\e[36m\]"
magenta="\[\e[35m\]"

_supports_truecolor() { [[ "${COLORTERM:-}" =~ (24bit|truecolor) ]]; }

if _supports_truecolor; then
  user_fg="\[$(rgb 110 210 65)\]"
  user_accent="\[$(rgb 200 120 255)\]"
  kube_fg="\[$(rgb 130 220 200)\]"
  git_fg="\[$(rgb 255 210 110)\]"
  time_fg="\[$(rgb 160 170 255)\]"
  err_bg="\[$(bgrgb 60 0 20)\]\[\e[97m\]"
  root_fg="\[$(rgb 255 110 110)\]"
  root_accent="\[$(rgb 255 170 80)\]"
else
  user_fg="\[\e[36m\]"
  user_accent="\[\e[35m\]"
  kube_fg="\[\e[32m\]"
  git_fg="\[\e[33m\]"
  time_fg="\[\e[34m\]"
  err_bg="\[\e[41m\]\[\e[97m\]"
  root_fg="\[\e[31m\]"
  root_accent="\[\e[91m\]"
fi

sym_branch=""; sym_time=""; sym_kube="Û±Éæ"; sym_venv=""; sym_host=""
sym_user="";  sym_root="Û∞åæ"; sym_sep=""

# Tirage d'un emoji correct
emojis=(üê∂ üê∫ üê± üê≠ üêπ üê∞ üê∏ üêØ üê® üêª üê∑ üêÆ üêµ üêº üêß üêç üê¢ üêô üê† üê≥ üê¨ üê• üí© üëπ üë∫ üíÄ üëª üëΩ ü§ñ üí© ü§Ø ü§© üòç üßô‚Äç‚ôÄÔ∏è üê∂ üê± üê≠ üêπ üê∞ ü¶ä üêª üêº üê® üêØ ü¶Å üêÆ üê∑ üêΩ üê∏ üêµ üôà üôâ üôä üêí üêî üêß üê¶ üê§ üê£ üê• ü¶Ü ü¶Ö ü¶â ü¶á üê∫ üêó üê¥ ü¶Ñ üêù üêõ ü¶ã üêå üêö üêû üêú ü¶ó ü¶Ç üê¢ üêç ü¶é ü¶ñ ü¶ï üêô ü¶ë ü¶ê ü¶Ä üê° üê† üêü üê¨ üê≥ üêã ü¶à üêä üêÖ üêÜ ü¶ì ü¶ç üêò ü¶è üê™ üê´ ü¶í üêÉ üêÇ üêÑ üêé üêñ üêè üêë üêê ü¶å üêï üê© üêà üêì ü¶É üêá üêÅ üêÄ ü¶î üêæ üêâ üê≤ üåµ üéÑ üå≤ üå≥ üå¥ üå± üåø ‚òòÔ∏è üçÄ üéç üéã üçÉ üçÇ üçÅ üçÑ üåæ üíê üå∑ üåπ ü•Ä üå∫ üå∏ üåº üåª üåû üåù üåà üé§ üéß üéº üéπ ü•Å üé∑ üé∫ üé∏ üéª üé≤ üíä üè¥‚Äç‚ò†Ô∏è üõ∞Ô∏è üöÄ üõ∏)
emoji="${emojis[RANDOM % ${#emojis[@]}]}"

_venv_name() {
  [[ -n "$VIRTUAL_ENV" ]] && basename "$VIRTUAL_ENV"
}
_git_branch() {
  command -v git >/dev/null 2>&1 || return
  git rev-parse --is-inside-work-tree &>/dev/null || return
  local b dirty=""
  b=$(git symbolic-ref --quiet --short HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null) || return
  git diff --no-ext-diff --quiet --ignore-submodules --cached || dirty="*"
  git diff --no-ext-diff --quiet --ignore-submodules || dirty="${dirty}+"
  printf "%s%s" "$b" "$dirty"
}
_last_status_segment() {
  local ec=$1
  [[ $ec -eq 0 ]] && return
  printf "‚úñ %d" "$ec"
}

# Chrono de la derni√®re commande
__TIMER_START=0
# Le trap DEBUG ne doit PAS se d√©clencher pendant PROMPT_COMMAND
trap '[[ -z "${__PROMPT_RUNNING:-}" ]] && __TIMER_START=$SECONDS' DEBUG
_last_cmd_duration() {
  local dur=$(( $1 - __TIMER_START ))
  (( dur > 1 )) && printf "%ss" "$dur"
}

# Historique partag√© sans flush co√ªteux (pas de 'history -c; history -r' √† chaque prompt)
__history_sync() {
  builtin history -a    # append new lines from this session
  builtin history -n    # read new lines from other sessions
}

# Wrapper PROMPT_COMMAND : capture $? et SECONDS AVANT toute autre action
__prompt_command() {
  local exit_code=$?
  local cmd_end=$SECONDS
  __PROMPT_RUNNING=1
  __history_sync
  __prompt_build "$exit_code" "$cmd_end"
  unset __PROMPT_RUNNING
}

__prompt_build() {
  local exit_code=${1:-0}
  local cmd_end=${2:-$SECONDS}
  local userpart hostpart git venv dur err

  if [[ $EUID -eq 0 ]]; then
    userpart="${root_fg}${bold}${sym_root} root${reset}"
    hostpart="${root_accent}${yellow} ${sym_host} \h${reset}"
  else
    userpart="${user_fg}${bold}${sym_user} \u${reset}"
    hostpart="${user_accent}${yellow} ${sym_host} \h${reset}"
  fi

  local gb; gb=$(_git_branch)
  [[ -n "$gb" ]] && git=" ${git_fg}${sym_branch} ${gb}${reset}"

  local vn; vn=$(_venv_name)
  [[ -n "$vn" ]] && venv=" ${time_fg}${sym_venv} ${vn}${reset}"

  dur=$(_last_cmd_duration "$cmd_end")
  [[ -n "$dur" ]] && dur=" ${time_fg}${sym_time} ${dur}${reset}"
  local st; st=$(_last_status_segment "$exit_code")
  [[ -n "$st" ]] && err=" ${err_bg} ${st} ${reset}"

  local line1="${userpart} at ${hostpart}${git}${venv}${dur}${err}\n"
  local pathpart="${bold}${blue}\w${reset}"
  local chevron; if [[ $EUID -eq 0 ]]; then chevron="${root_fg}#${reset}"; else chevron="${user_fg}\$${reset}"; fi
  PS1="\n${emoji} \[\e[0;36m\][\t]\[\e[0;m\] ${line1}${pathpart} ${chevron} "
}

# Compose PROMPT_COMMAND (idempotent au re-source)
__install_prompt_command() {
  [[ "${PROMPT_COMMAND:-}" == *"__prompt_command"* ]] && return
  if declare -p PROMPT_COMMAND 2>/dev/null | grep -q 'declare \-a'; then
    PROMPT_COMMAND+=(__prompt_command)
  elif [[ -n "${PROMPT_COMMAND:-}" ]]; then
    PROMPT_COMMAND="__prompt_command; ${PROMPT_COMMAND}"
  else
    PROMPT_COMMAND="__prompt_command"
  fi
}
__install_prompt_command

# --- Completions
if [[ -r /usr/share/bash-completion/bash_completion ]]; then
  . /usr/share/bash-completion/bash_completion
elif [[ -r /etc/bash_completion ]]; then
  . /etc/bash_completion
fi
if declare -F _git >/dev/null 2>&1; then
  complete -o default -o nospace -F _git g
fi
command -v composer >/dev/null 2>&1 && eval "$(composer completion bash 2>/dev/null)" || true
command -v symfony  >/dev/null 2>&1 && eval "$(symfony  completion bash 2>/dev/null)" || true
[[ -f "$HOME/.fzf.bash" ]] && . "$HOME/.fzf.bash"

# --- GPG TTY (utile pour les commits sign√©s)
command -v gpg >/dev/null 2>&1 && export GPG_TTY="$(tty)"

# --- Banner hostname avec toilet/figlet + infos syst√®me (une seule fois par session)
__motd_once() {
  [[ -n "${BASHRC_MOTD_SHOWN:-}" ]] && return
  [[ -t 1 ]] || return
  local host
  host=$(hostname -s)
  if command -v toilet >/dev/null 2>&1; then
    toilet -f smblock --filter border "$host" 2>/dev/null | lolcat 2>/dev/null || toilet -f smblock "$host" 2>/dev/null
  elif command -v figlet >/dev/null 2>&1; then
    figlet -f small "$host" 2>/dev/null | lolcat 2>/dev/null || figlet -f small "$host" 2>/dev/null
  else
    echo -e "\n  \e[1;35m>>> $host <<<\e[0m\n"
  fi
  if command -v fastfetch >/dev/null 2>&1; then
    fastfetch --logo none --structure OS:Kernel:Uptime:Memory 2>/dev/null
  fi
  export BASHRC_MOTD_SHOWN=1
}
__motd_once || true

# Source cargo/rustup si pr√©sent
[[ -f "$HOME/.cargo/env" ]] && . "$HOME/.cargo/env"
